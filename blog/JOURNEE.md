---
title : "AIと対話して旅のしおりを作る「Journee」を4日で作った話 - Next.js App Router × Supabase × Gemini API"
emoji : "✈️"
type : "tech"
topics : ["nextjs","ai","supabase","個人開発","typescript"]
published : false
---

## 旅行は計画を立てている時間が、一番楽しい

次の旅行先はどこにしようか。
どんな場所を訪れようか。
何を食べようか。
どんな景色が待っているだろうか。

旅行の計画を立てている時、頭の中は既に旅先にいます。
地図を眺めながら、観光スポットを調べながら、レストランのレビューを読みながら。
その全てが、旅の楽しみの一部です。

でも、その情報を「しおり」という形にまとめるのは、意外と大変だったりします。
ExcelやGoogleドキュメントに書き出して、フォーマットを整えて、地図のリンクを貼って。
情報を整理する作業に時間を取られて、肝心の「どこに行くか考える楽しみ」が減ってしまう。

**もっと楽しく、もっと自然に、旅のしおりが作れたら。**
**AIと会話しているうちに、いつの間にかしおりが完成していたら。**

そんな「素晴らしい旅のお供」を目指して、**AIと対話しながら旅のしおりを作れるWebアプリ「Journee」**を作りました。

<!-- 
スクリーンショット1: アプリのメイン画面
- チャットとしおりプレビューの2カラムレイアウト
- 実際に会話している様子
- しおりが表示されている状態
推奨サイズ: 1200x800程度
-->

**この記事を読むことでわかること：**
- 個人開発でAI統合Webアプリを作る具体的な方法
- Next.js 14 App Routerの実践的な使い方
- ストリーミングレスポンスの実装パターン
- Supabase統合のベストプラクティス
- リアルタイムUI更新の実装方法
- 本番環境へのデプロイまでの道のり

**技術スタック：**
- Next.js 14 (App Router)
- TypeScript
- Supabase (PostgreSQL)
- NextAuth.js
- Google Gemini API / Anthropic Claude API
- Kubernetes + ArgoCD

## なぜ作ったのか

<!-- ここに記載する内容：個人的な動機と課題意識 -->
<!--
- 旅行好きだが、しおり作成に時間がかかりすぎる問題
- 既存のツールの不満点（柔軟性がない、デザインがイマイチなど）
- AIの力を借りれば、もっと楽しく効率的にできるはず
- 技術的な挑戦としても面白そうだった
-->

[背景と動機を記載]

## 想定読者

### このブログが役立つ人
- Next.js App Routerでの実践的な開発経験を知りたい
- AI APIの統合方法を学びたい
- 個人開発でフルスタックアプリを作りたい
- Supabaseの実践的な使い方を知りたい
- ストリーミングレスポンスの実装方法を知りたい

### 想定しないレベル
- Next.jsやReactを全く触ったことがない方
  - （ただし、興味があれば参考になる部分は多いです）

## Journeeの特徴

<!-- ここに記載する内容：アプリの主要機能 -->
<!--
1. **AIとの対話でしおり作成**
   - チャット形式で自然に情報収集
   - 段階的な質問で必要な情報を引き出す
   
2. **リアルタイムプレビュー**
   - リサイズ可能な2カラムレイアウト
   - チャットしながらしおりが更新される様子を確認
   
3. **柔軟な編集機能**
   - 各スポットをインライン編集
   - スポットの追加・削除
   - Undo/Redo機能
   
4. **共有とエクスポート**
   - 公開URLでしおりを共有
   - PDF出力機能
   - OGP画像の動的生成
   
5. **認証とデータ永続化**
   - Google OAuth認証
   - Supabaseでのデータ保存
   - 複数デバイス間での同期
-->

### 1. AIとの対話でしおり作成

[詳細を記載]

<!-- 
スクリーンショット2: チャット画面での対話例
- AIが段階的に質問している様子
- チェックリストが更新されていく様子
- ストリーミングでテキストが生成される様子（可能であればGIF）
推奨サイズ: 800x600程度
-->

### 2. リアルタイムプレビュー

[詳細を記載]

<!-- 
スクリーンショット3: リサイズ機能のデモ
- リサイズハンドルが見える状態
- チャット領域としおり領域の比率が調整できる様子
推奨サイズ: 1200x600程度
-->

<!-- 
スクリーンショット4: モバイル表示
- タブ切り替えUI
- チャットとしおりをタブで切り替える様子
推奨サイズ: 375x812（iPhone画面サイズ）
-->

### 3. 柔軟な編集機能

[詳細を記載]

<!-- 
スクリーンショット5: インライン編集
- スポットをクリックして編集している状態
- 編集フォームが開いている様子
推奨サイズ: 800x600程度
-->

<!-- 
スクリーンショット6: Undo/Redo機能
- Undo/Redoボタンが表示されている様子
- 操作履歴が分かる状態
推奨サイズ: 600x400程度
-->

### 4. 共有とエクスポート

[詳細を記載]

<!-- 
スクリーンショット7: 公開しおり表示
- 公開URLでアクセスした際の表示
- コメント機能が見える状態
推奨サイズ: 1000x800程度
-->

<!-- 
スクリーンショット8: PDF出力プレビュー
- PDFプレビューモーダル
- 生成されたPDFのプレビュー
推奨サイズ: 800x600程度
-->

<!-- 
スクリーンショット9: OGP画像
- SNSでシェアした際のプレビュー（TwitterやSlackなど）
- 動的生成されたOGP画像
推奨サイズ: 1200x630（OGP標準サイズ）
-->

### 5. 認証とデータ永続化

[詳細を記載]

<!-- 
スクリーンショット10: マイページ
- しおり一覧が表示されている状態
- ユーザープロフィール
- 統計情報
推奨サイズ: 1200x800程度
-->

## アーキテクチャ概要

<!-- 
図1: システムアーキテクチャ図
- フロントエンド、バックエンド、外部サービスの関係図
- データフローが分かる図
- MermaidやPlantUMLで作成するか、手書き図をきれいにしたもの
推奨: ベクター形式（SVG）またはPNG
-->

```
[ユーザー] → [Next.js App Router]
                 ↓
        [API Routes（ストリーミング対応）]
                 ↓
    [Gemini API / Claude API]
                 ↓
        [Zustand（状態管理）]
                 ↓
           [Supabase（永続化）]
```

<!-- 
図2: データフロー図
- ユーザーの入力からしおり生成までの流れ
- 各コンポーネント間のデータのやり取り
推奨: シーケンス図形式
-->

### 使用した主要技術とその理由

**フロントエンド：**
- **Next.js 14 App Router**: サーバーコンポーネントとストリーミングの活用
- **TypeScript**: 型安全性による開発効率向上
- **Tailwind CSS**: 高速なスタイリング
- **Zustand**: シンプルで強力な状態管理

**バックエンド：**
- **Supabase**: PostgreSQLベースの使いやすいBaaS
- **NextAuth.js**: 認証の標準ライブラリ
- **Google Gemini API**: 高速で安価なAI
- **Anthropic Claude API**: 高品質な回答生成

**インフラ：**
- **Kubernetes**: コンテナオーケストレーション
- **ArgoCD**: GitOpsによる継続的デプロイ
- **Cloudflare Tunnel**: SSL対応のドメイン発行

## 技術的な工夫ポイント

### 1. ストリーミングレスポンスによるUX向上

<!-- ここに記載する内容：ストリーミング実装の詳細 -->
<!--
- ReadableStreamを使ったストリーミング実装
- TextDecoderでのチャンク処理
- フロントエンドでのリアルタイム表示
- エラーハンドリングとリトライ
-->

**課題：**
AIのレスポンスを待つ間、ユーザーが何も見えないと不安になる

**解決策：**
ストリーミングレスポンスで、生成されたテキストをリアルタイムに表示

**実装例：**

```typescript
// app/api/chat/route.ts（抜粋）
// [コード例を挿入予定]
```

**ポイント：**
- [ポイント1]
- [ポイント2]
- [ポイント3]

<!-- 
スクリーンショット11: ストリーミング中の画面
- テキストが徐々に表示される様子
- ローディング状態が分かる
推奨: GIFアニメーションが理想、または連続したスクリーンショット
推奨サイズ: 800x400程度
-->

### 2. リサイズ可能レイアウトの実装

<!-- ここに記載する内容：リサイズ機能の実装詳細 -->
<!--
- マウスドラッグでの幅調整
- LocalStorageへの保存
- モバイル対応（タブ切り替え）
- スムーズなアニメーション
-->

**課題：**
チャットとしおりプレビューを同時に見たいが、画面が狭い

**解決策：**
リサイズ可能な2カラムレイアウトで、ユーザーが自由に調整可能に

**実装のポイント：**
- [ポイント1]
- [ポイント2]

<!-- 
スクリーンショット12: リサイズハンドルの詳細
- ドラッグ可能なハンドルのUI
- ホバー時の表示
推奨サイズ: 600x400程度
-->

### 3. 段階的な情報収集フロー

<!-- ここに記載する内容：チェックリスト機能の実装 -->
<!--
- 旅行計画に必要な情報を定義
- AIがチェックリストを確認しながら質問
- ユーザーにとって自然な会話フロー
- 情報が揃ったら自動的に次のフェーズへ
-->

**課題：**
ユーザーがどんな情報を提供すればいいかわからない

**解決策：**
AIが段階的に質問し、必要な情報を収集する仕組み

**フェーズ管理：**
1. **情報収集フェーズ**: 基本情報（行き先、日数など）
2. **骨組み作成フェーズ**: 大まかな日程を作成
3. **詳細化フェーズ**: 各日の詳細スポットを追加

<!-- 
スクリーンショット13: フェーズステータスバー
- 現在のフェーズが視覚的に分かるUI
- チェックリスト項目が表示されている状態
推奨サイズ: 800x200程度
-->

<!-- 
図3: フェーズ遷移図
- 各フェーズの流れを示す図
- どの条件でフェーズが進むかを明示
推奨: フローチャート形式
-->

### 4. Supabaseとの統合

<!-- ここに記載する内容：データベース設計と統合 -->
<!--
- テーブル設計（itineraries、users、commentsなど）
- Row Level Security（RLS）の活用
- LocalStorageからの段階的マイグレーション
- リアルタイムサブスクリプション
-->

**課題：**
LocalStorageだけではデータが失われるリスクがある

**解決策：**
Supabaseで永続化し、複数デバイス間で同期

**テーブル設計：**

```sql
-- [スキーマ例を挿入予定]
```

<!-- 
図4: データベーススキーマ図（ER図）
- テーブル間のリレーション
- 主要なカラムの表示
- 外部キー制約
推奨: ER図ツール（dbdiagram.ioなど）で作成
-->

<!-- 
スクリーンショット14: Supabase管理画面
- テーブル構造が確認できる画面
- RLSポリシーの設定画面
推奨サイズ: 1000x600程度
-->

**セキュリティ：**
- Row Level Security（RLS）でユーザーごとにアクセス制御
- [その他のポイント]

### 5. NextAuth.jsでの認証

<!-- ここに記載する内容：認証実装の詳細 -->
<!--
- Google OAuth認証
- JWT戦略
- セッション管理
- ミドルウェアでの保護
-->

**課題：**
認証なしだとデータの所有権が曖昧

**解決策：**
NextAuth.jsでGoogle OAuth認証を実装

**実装のポイント：**
- [ポイント1]
- [ポイント2]

<!-- 
スクリーンショット15: ログイン画面
- Google OAuth認証ボタン
- NextAuth.jsのサインイン画面
推奨サイズ: 600x400程度
-->

### 6. OGP画像の動的生成

<!-- ここに記載する内容：OGP画像生成の実装 -->
<!--
- @vercel/ogを使用
- しおりの情報を含めた画像生成
- SNS共有時のプレビュー最適化
-->

**課題：**
共有時に魅力的なプレビューを表示したい

**解決策：**
`@vercel/og`で動的にOGP画像を生成

**実装例：**

```tsx
// app/api/og/route.tsx（抜粋）
// [コード例を挿入予定]
```

<!-- 
スクリーンショット16: 実際に生成されたOGP画像
- しおりのタイトルや行き先が含まれている
- 視覚的に魅力的なデザイン
推奨サイズ: 1200x630（OGP標準）
-->

### 7. E2Eテストの導入

<!-- ここに記載する内容：テスト戦略 -->
<!--
- Playwrightでのテスト
- 主要フローのカバレッジ
- CI/CDへの統合
-->

**課題：**
機能追加時に既存機能が壊れていないか不安

**解決策：**
Playwrightで主要フローをテスト

**テスト例：**
- [テスト1]
- [テスト2]

<!-- 
スクリーンショット17: Playwrightテスト実行結果
- テストレポート画面
- 成功・失敗が分かる状態
推奨サイズ: 1000x600程度
-->

<!-- 
スクリーンショット18: テストコード例
- 実際のテストコードのスクリーンショット
- わかりやすくコメント付き
推奨サイズ: 800x500程度
-->

## 開発の流れと苦労した点

### Phase 1: プロトタイプ作成

<!-- ここに記載する内容：初期開発 -->
<!--
- まずはローカルで動くものを作成
- LocalStorageでの保存
- 基本的なチャット機能
-->

[詳細を記載]

<!-- 
スクリーンショット19: 初期プロトタイプ
- 最初期のUIデザイン
- シンプルな構成
推奨サイズ: 1000x600程度
-->

### Phase 2: AI統合

<!-- ここに記載する内容：AI統合の苦労 -->
<!--
- プロンプトエンジニアリング
- レスポンスパースの工夫
- エラーハンドリング
-->

[詳細を記載]

<!-- 
スクリーンショット20: プロンプトの試行錯誤
- 使用したプロンプト例
- AIのレスポンス例
推奨サイズ: 800x600程度
-->

### Phase 3: UI/UX改善

<!-- ここに記載する内容：UI改善 -->
<!--
- リサイズ機能の追加
- モバイル対応
- アニメーション追加
-->

[詳細を記載]

<!-- 
スクリーンショット21: UI改善のビフォー・アフター
- 改善前と改善後の比較
- 並べて表示
推奨サイズ: 1200x600程度（2画面並べる）
-->

### Phase 4: データベース統合

<!-- ここに記載する内容：Supabase統合の苦労 -->
<!--
- スキーマ設計
- マイグレーション実装
- RLSの設定
-->

[詳細を記載]

<!-- 
スクリーンショット22: マイグレーションプロンプト
- LocalStorageからSupabaseへの移行を促すUI
- ユーザー体験を損なわない実装
推奨サイズ: 600x400程度
-->

### Phase 5: 認証と公開機能

<!-- ここに記載する内容：認証実装 -->
<!--
- NextAuth.js導入
- 公開URL機能
- コメント機能
-->

[詳細を記載]

<!-- 
スクリーンショット23: コメント機能
- 公開しおりでのコメント表示
- コメント投稿フォーム
推奨サイズ: 800x600程度
-->

### Phase 6: 本番デプロイ

<!-- ここに記載する内容：デプロイ -->
<!--
- Kubernetes環境構築
- CI/CD整備
- モニタリング
-->

[詳細を記載]

<!-- 
図5: インフラ構成図
- Kubernetes、ArgoCD、Cloudflare Tunnelの構成
- CI/CDパイプライン
推奨: ネットワーク図形式
-->

<!-- 
スクリーンショット24: ArgoCD管理画面
- アプリケーションの同期状態
- デプロイの状態が分かる画面
推奨サイズ: 1200x800程度
-->

## パフォーマンス最適化

### クライアント側の最適化

<!-- ここに記載する内容：フロントエンド最適化 -->
<!--
- React.memoの活用
- useMemo、useCallbackの適切な使用
- 不要な再レンダリング防止
- 画像最適化
-->

[詳細を記載]

<!-- 
スクリーンショット25: Chrome DevTools Performance
- パフォーマンス計測結果
- レンダリング最適化の効果
推奨サイズ: 1000x600程度
-->

### サーバー側の最適化

<!-- ここに記載する内容：バックエンド最適化 -->
<!--
- APIレスポンスのキャッシュ
- データベースクエリの最適化
- ストリーミングの活用
-->

[詳細を記載]

<!-- 
スクリーンショット26: APIレスポンスタイム
- レスポンス時間の計測結果
- 最適化前後の比較
推奨サイズ: 800x400程度
-->

## 運用とモニタリング

<!-- ここに記載する内容：運用面 -->
<!--
- ログ収集
- エラートラッキング
- パフォーマンスモニタリング
- コスト管理
-->

[詳細を記載]

<!-- 
スクリーンショット27: モニタリングダッシュボード
- アクセス状況
- エラー率
- レスポンスタイム
推奨サイズ: 1200x700程度
-->

## 今後の展望

<!-- ここに記載する内容：今後の計画 -->
<!--
- 多言語対応
- AIモデルの選択肢追加
- コラボレーション機能
- モバイルアプリ化
-->

1. **多言語対応**
   - [詳細]

2. **AIモデルの選択肢追加**
   - [詳細]

3. **コラボレーション機能**
   - [詳細]

4. **モバイルアプリ化**
   - [詳細]

<!-- 
スクリーンショット28: モックアップ
- 今後追加予定の機能のモックアップやワイヤーフレーム
- ビジョンが伝わる画像
推奨サイズ: 1000x700程度
-->

## まとめ

### 実現できたこと
- AIとの対話で直感的にしおりを作成できる仕組み
- ストリーミングレスポンスによる快適なUX
- リサイズ可能レイアウトでの柔軟な画面構成
- Supabaseでの安全なデータ永続化
- NextAuth.jsでの簡単な認証実装
- Kubernetes/ArgoCDでの本番環境構築

### 学んだこと
<!-- ここに記載する内容：開発を通じて学んだこと -->
<!--
- AI統合の実践的なノウハウ
- Next.js App Routerの実戦投入
- Supabaseの実践的な使い方
- 個人開発でのインフラ構築
-->

[詳細を記載]

### 参考リンク

**プロジェクト：**
- [Journeeリポジトリ](https://github.com/AobaIwaki123/journee)
- [デモサイト](https://journee.example.com)

**技術ドキュメント：**
- [Next.js 公式ドキュメント](https://nextjs.org/docs)
- [Supabase 公式ドキュメント](https://supabase.com/docs)
- [NextAuth.js 公式ドキュメント](https://next-auth.js.org/)

**関連記事：**
- [ブランチごとに独立環境を立てて爆速開発する方法](#)（前回の記事）

この記事が役に立ったら、[Journeeリポジトリ](https://github.com/AobaIwaki123/journee)にスターをいただけると嬉しいです ⭐

個人開発でもここまでできる、という可能性を感じてもらえたら幸いです。
何か質問があれば、コメント欄やTwitterでお気軽にどうぞ！

<!-- 
スクリーンショット29: GitHubリポジトリのトップページ
- READMEが見える状態
- スター数やフォーク数が分かる
推奨サイズ: 1200x800程度
-->

<!-- 
図6: 開発タイムライン
- 2週間の開発の流れを視覚化
- 各Phaseの期間と内容
推奨: ガントチャート形式
-->

---

**開発期間**: 2週間（2025年9月-10月）
**総コミット数**: [数字]
**使用言語**: TypeScript 95%, CSS 3%, JavaScript 2%

<!-- 
スクリーンショット30: GitHubのInsights画面
- コミット履歴
- 言語構成グラフ
推奨サイズ: 1000x600程度
-->

